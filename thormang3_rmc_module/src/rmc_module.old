/*
 *  rmc_module.cpp
 *
 *  Created on: 2019/06/25
 *      Author: Matsushima
 */

#include "thormang3_rmc_module/rmc_module.h"

using namespace thormang3;

RMCModule::RMCModule()
  : control_cycle_sec_(0.008)
{
  enable_       = false;
  module_name_  = "rmc_module";
  control_mode_ = robotis_framework::PositionControl;
  // control_mode_ = robotis_framework::VelocityControl;
  // control_mode_ = robotis_framework::TorqueControl;
  
  /* arm */
  result_["r_arm_sh_p1"]  = new robotis_framework::DynamixelState();
  result_["l_arm_sh_p1"]  = new robotis_framework::DynamixelState();
  result_["r_arm_sh_r"]   = new robotis_framework::DynamixelState();
  result_["l_arm_sh_r"]   = new robotis_framework::DynamixelState();
  result_["r_arm_sh_p2"]  = new robotis_framework::DynamixelState();
  result_["l_arm_sh_p2"]  = new robotis_framework::DynamixelState();
  result_["r_arm_el_y"]   = new robotis_framework::DynamixelState();
  result_["l_arm_el_y"]   = new robotis_framework::DynamixelState();
  result_["r_arm_wr_r"]   = new robotis_framework::DynamixelState();
  result_["l_arm_wr_r"]   = new robotis_framework::DynamixelState();
  result_["r_arm_wr_y"]   = new robotis_framework::DynamixelState();
  result_["l_arm_wr_y"]   = new robotis_framework::DynamixelState();
  result_["r_arm_wr_p"]   = new robotis_framework::DynamixelState();
  result_["l_arm_wr_p"]   = new robotis_framework::DynamixelState();
  result_["torso_y"]      = new robotis_framework::DynamixelState();

  /* arm */
  joint_name_to_id_["r_arm_sh_p1"] = 1;
  joint_name_to_id_["l_arm_sh_p1"] = 2;
  joint_name_to_id_["r_arm_sh_r"]  = 3;
  joint_name_to_id_["l_arm_sh_r"]  = 4;
  joint_name_to_id_["r_arm_sh_p2"] = 5;
  joint_name_to_id_["l_arm_sh_p2"] = 6;
  joint_name_to_id_["r_arm_el_y"]  = 7;
  joint_name_to_id_["l_arm_el_y"]  = 8;
  joint_name_to_id_["r_arm_wr_r"]  = 9;
  joint_name_to_id_["l_arm_wr_r"]  = 10;
  joint_name_to_id_["r_arm_wr_y"]  = 11;
  joint_name_to_id_["l_arm_wr_y"]  = 12;
  joint_name_to_id_["r_arm_wr_p"]  = 13;
  joint_name_to_id_["l_arm_wr_p"]  = 14;
  joint_name_to_id_["torso_y"]     = 27;

  /* etc */
  joint_name_to_id_["r_arm_end"]   = 35;
  joint_name_to_id_["l_arm_end"]   = 34;

  /* parameter */
  present_joint_position_   = Eigen::VectorXd::Zero(MAX_JOINT_ID+1);
  goal_joint_position_      = Eigen::VectorXd::Zero(MAX_JOINT_ID+1);
  init_joint_position_      = Eigen::VectorXd::Zero(MAX_JOINT_ID+1);

  ik_id_start_  = 0;
  ik_id_end_    = 0;

  ik_target_position_   = Eigen::MatrixXd::Zero(3,1);
  ik_weight_            = Eigen::MatrixXd::Zero(MAX_JOINT_ID+1, 1);
  ik_weight_.fill(1.0);
  
  robotis_                   = new KinematicsDynamics(WholeBody);
}

RMCModule::~RMCModule()
{
  queue_thread_.join();
}

void RMCModule::initialize(const int control_cycle_msec, robotis_framework::Robot *robot)
{
  // control_cycle_msec_ = control_cycle_msec;
  queue_thread_ = boost::thread(boost::bind(&RMCModule::queueThread, this));

  std::string _path = ros::package::getPath("thormang3_rmc_module") + "/config/ik_weight.yaml";
  parseData(_path);
}

void RMCModule::parseData(const std::string &path)
{
  YAML::Node doc;
  try
  {
    // load yaml
    doc = YAML::LoadFile(path.c_str());
  } catch (const std::exception& e)
  {
    ROS_ERROR("Fail to load yaml file.");
    return;
  }

  YAML::Node ik_weight_node = doc["weight_value"];
  for (YAML::iterator it = ik_weight_node.begin(); it != ik_weight_node.end(); ++it)
  {
    int     id    = it->first.as<int>();
    double  value = it->second.as<double>();

    ik_weight_.coeffRef(id, 0) = value;
  }
}

void RMCModule::queueThread()
{
  ros::NodeHandle ros_node;
  ros::CallbackQueue callback_queue;

  ros_node.setCallbackQueue(&callback_queue);

  /* subscriber */
  // sub1_ = ros_node.subscribe("/tutorial_topic", 10, &RMCModuleTutorial::topicCallback, this);
  // ros::Subscriber pos_sub = ros_node.subscribe("/robotis/rmc/pos_msg", 5,
  //                                                       &RMCModule::topicCallback, this);
  ros::Subscriber kinematics_pose_msg_sub = ros_node.subscribe("/robotis/rmc/kinematics_pose_msg", 5,
                                                               &RMCModule::kinematicsPoseMsgCallback, this);
  ros::WallDuration duration(control_cycle_sec_);
  while(ros_node.ok())
    callback_queue.callAvailable(duration);
}

// void RMCModule::topicCallback(const std_msgs::Float64 &msg)
// {
//   des_pos = msg;
//   sub_flag = 1;
//   // std::cout << "des pos" << des_pos.data <<std::endl;
// }

// void ManipulationModule::setInverseKinematics(int cnt, Eigen::MatrixXd start_rotation)
// {
//   for (int dim = 0; dim < 3; dim++)
//     ik_target_position_.coeffRef(dim, 0) = goal_task_tra_.coeff(cnt, dim);

//   Eigen::Quaterniond start_quaternion = robotis_framework::convertRotationToQuaternion(start_rotation);

//   Eigen::Quaterniond target_quaternion(goal_kinematics_pose_msg_.pose.orientation.w,
//                                        goal_kinematics_pose_msg_.pose.orientation.x,
//                                        goal_kinematics_pose_msg_.pose.orientation.y,
//                                        goal_kinematics_pose_msg_.pose.orientation.z);

//   double count = (double) cnt / (double) all_time_steps_;

//   Eigen::Quaterniond _quaternion = start_quaternion.slerp(count, target_quaternion);

//   ik_target_rotation_ = robotis_framework::convertQuaternionToRotation(_quaternion);
// }

void RMCModule::kinematicsPoseMsgCallback(const thormang3_manipulation_module_msgs::KinematicsPose::ConstPtr& msg)
{
  if (enable_ == false)
    return;

  goal_kinematics_pose_msg_ = *msg;

  if (goal_kinematics_pose_msg_.name == "left_arm")
  {
    ik_id_start_  = ID_L_ARM_START;
    ik_id_end_    = ID_L_ARM_END;
  }
  else if (goal_kinematics_pose_msg_.name == "right_arm")
  {
    ik_id_start_  = ID_R_ARM_START;
    ik_id_end_    = ID_R_ARM_END;
  }
  else if (goal_kinematics_pose_msg_.name == "left_arm_with_torso")
  {
    ik_id_start_  = ID_TORSO;
    ik_id_end_    = ID_L_ARM_END;
  }
  else if (goal_kinematics_pose_msg_.name == "right_arm_with_torso")
  {
    ik_id_start_  = ID_TORSO;
    ik_id_end_    = ID_R_ARM_END;
  }

  sub_flag = 1;
  
  return;
}

Eigen::MatrixXd RMCModule::pInv(Eigen::MatrixXd A)
{
  return A.transpose() * (A * A.transpose()).inverse();
}

bool RMCModule::calcRMC(Eigen::MatrixXd S,
                        Eigen::VectorXd P_ref,
                        Eigen::VectorXd L_ref,
                        std::vector<Eigen::Matrix<double,6,1>> guzai_i_ref)
{
  // ros::init(argc,argv,"thormang3_rmc_module");

  thormang3::KinematicsDynamics* thormang3_kd_;
  thormang3_kd_ = new KinematicsDynamics(WholeBody);

  thormang3_kd_->calcForwardKinematics(0);//
  
  //現時刻における角度θ、ベースリンクの位置/姿勢 pb/Rbから行列Aを求める
  Eigen::MatrixXd I_tilde;//全重心回りの慣性行列
  I_tilde = thormang3_kd_->calcInertiaC();
  std::vector<Eigen::MatrixXd> M(4);
  std::vector<Eigen::MatrixXd> H(4);
  std::vector<Eigen::MatrixXd> H_(4);
  std::vector<int> MH_id_from = {1,2,0,0};
  std::vector<int> MH_id_to = {35,34,25,26};
  std::vector<int> MH_id = {35,34,45,46};
  std::vector<int> idx_;
  Eigen::VectorXi idx;
  Eigen::Vector3d a = Eigen::Vector3d::UnitZ();//たぶん...//違う？thormang3_link_data_[id]->joint_axis_ かも...
  Eigen::Vector3d c_tilde_j = Eigen::VectorXd::Zero(3);
  double m_tilde_j = 0.0;
  Eigen::Matrix3d I_tilde_j = Eigen::MatrixXd::Zero(3,3);
  // Eigen::Vector3d c_tilde_j_1 = Eigen::VectorXd::Zero(3);
  // double m_tilde_j_1 = 0.0;
  // Eigen::Matrix3d I_tilde_j_1 = Eigen::MatrixXd::Zero(3,3);

  Eigen::Vector3d r_j;//
  // Eigen::MatrixXd D;
  Eigen::Vector3d m_j;
  Eigen::Vector3d h_j;
  for (int i=0; i<MH_id.size(); i++){
    idx_ = thormang3_kd_->findRoute(MH_id_from[i],MH_id_to[i]);
    // idx_ = thormang3_kd_->findRoute(MH_id[i]);
    idx = Eigen::Map<Eigen::VectorXi>(&idx_[0], idx_.size());
    int end_id = idx.size() - 1;
    M[i] = Eigen::MatrixXd::Zero(3,idx.size());
    H[i] = Eigen::MatrixXd::Zero(3,idx.size());
    H_[i] = Eigen::MatrixXd::Zero(3,idx.size());
    for (int j=0; j<idx.size(); j++){
      m_tilde_j = thormang3_kd_->calcTotalMass(idx(end_id - j));
      c_tilde_j = thormang3_kd_->calcCenterOfMass(idx(end_id - j));
      I_tilde_j = thormang3_kd_->calcInertiaC(idx(end_id - j));

      r_j = thormang3_kd_->thormang3_link_data_[idx(end_id - j)]->position_;
      m_j = thormang3_kd_->cross(thormang3_kd_->thormang3_link_data_[end_id - j]->joint_axis_) * (c_tilde_j - r_j) * m_tilde_j;
      // m_j = thormang3_kd_->cross(a) * (c_tilde_j - r_j) * m_tilde_j;
      h_j = thormang3_kd_->cross(c_tilde_j) * m_j + I_tilde_j * a;
      M[i].col(end_id - j) = m_j;
      H_[i].col(end_id - j) = h_j;
    }
    H[i] = H_[i] - thormang3_kd_->cross(thormang3_kd_->calcCenterOfMass(0))*M[i];
  }
  // std::cout <<"M"<<std::endl<<M[0] <<std::endl;

  std::vector<Eigen::MatrixXd> J(4);
  // std::vector<int> KinematicsDynamics::findRoute(int to)
  // std::vector<int> KinematicsDynamics::findRoute(int from, int to)
  // J[0] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(35));
  // J[1] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(34));
  // J[2] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(45));
  // J[3] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(46));
  // J[0] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(1,35));
  // J[1] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(2,34));
  // J[2] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(15,45));
  // J[3] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(16,46));
  // J[0] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(1,13));
  // J[1] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(2,14));
  // J[2] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(15,25));
  // J[3] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(16,26));
  // J[0] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(1,35));
  // J[1] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(2,34));
  // J[2] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(15,45));
  // J[3] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(16,46));
  for (int i=0; i<MH_id.size(); i++){
    J[i] = thormang3_kd_->calcJacobian(thormang3_kd_->findRoute(MH_id_from[i],MH_id_to[i]));
  }
  // std::cout <<"J1"<<J[0] <<std::endl;
  // std::cout <<"J2"<<J[1] <<std::endl;
  // std::cout <<"J3"<<J[2] <<std::endl;
  // std::cout <<"J4"<<J[3] <<std::endl;
  // std::cout <<"J" << 3 << std::endl << J[3] << std::endl;
  // std::cout <<"pInv" << 3 << std::endl << pInv(J[3]) << std::endl;
  // std::cout <<"Inv" << 3 << std::endl << J[3].inverse() << std::endl;
  
  //Eigen::MatrixXd M_b;
  //Eigen::MatrixXd H_b;
  double m_tilde;//全質量
  m_tilde = thormang3_kd_->calcTotalMass(0);
  // ROS_INFO("m_tide");
  // std::cout <<m_tilde<<std::endl;
  Eigen::MatrixXd c_tilde(3,1);//全重心位置
  c_tilde = thormang3_kd_->calcCenterOfMass(0);
  // ROS_INFO("c_tide");
  // std::cout <<c_tilde<<std::endl;
  Eigen::VectorXd th; //現在角度
  Eigen::VectorXd p_b(3); //現在のベースリンクの位置
  // Eigen::VectorXd R_b(3); //現在のベースリンクの姿勢
  p_b = thormang3_kd_->thormang3_link_data_[0]->position_;
  // std::cout <<"p_b" << std::endl << p_b << std::endl;
  // R_b = thormang3_kd_->thormang3_link_data_[0]->orientation_;
  // std::cout <<"R_b" << std::endl << R_b << std::endl;
  Eigen::VectorXd r_B_c(3);//ボディから全重心への位置ベクトル
  r_B_c = c_tilde - p_b;
  std::vector<Eigen::VectorXd> r_B_i(4);//ボディから四肢先端への位置ベクトル
  //右手(r_B_i(0)),左手(r_B_i(1)),右足(r_B_i(2)),左足(r_B_i(3))
  for(int i=0; i<MH_id.size();i++){
    r_B_i[i] = thormang3_kd_->thormang3_link_data_[MH_id[i]]->position_;
  }
  // r_B_i[0] = thormang3_kd_->thormang3_link_data_[35]->position_;//右手
  // r_B_i[1] = thormang3_kd_->thormang3_link_data_[34]->position_;//左手
  // r_B_i[2] = thormang3_kd_->thormang3_link_data_[45]->position_;//右足
  // r_B_i[3] = thormang3_kd_->thormang3_link_data_[46]->position_;//左足
  
  Eigen::MatrixXd A_1(6,6);//Inertia matrix の計算に必要な行列
  // std::vector<Eigen::MatrixXd> A_2(4);//Inertia matrix の計算に必要な行列
  std::vector<Eigen::Matrix<double,6,6>> A_3(4);//Inertia matrix の計算に必要な行列

  A_1 <<
    m_tilde * Eigen::MatrixXd::Identity(3,3) , -m_tilde * thormang3_kd_->cross(r_B_c),
    Eigen::MatrixXd::Zero(3,3)               , I_tilde;
  for(int i=0; i<4; i++){
    Eigen::MatrixXd A_2(M[i].col(0).size() * 2,M[i].row(0).size());
    //Inertia matrix の計算に必要な行列
    A_2 <<
      M[i],
      H[i];

    A_3[i] <<
      Eigen::MatrixXd::Identity(3,3) , -thormang3_kd_->cross(r_B_i[i]),
      Eigen::MatrixXd::Zero(3,3)     , Eigen::MatrixXd::Identity(3,3);

    A_1 += - A_2 * pInv(J[i]) * A_3[i];
  }

  //for(i = 0; i<4; i++) A1 += -A2(i) * inv(J(i)) * A3(i);
  // Eigen::MatrixXd A(6, A_1.cols() + MH_free.cols());
  // A << A_1,MH_free;
  // A = S * A;
  Eigen::MatrixXd A;
  A = S * A_1;
  // std::cout <<"A" << std::endl << A << std::endl;
  
  //とりあえずFreeは無視している
  //目標全運動量P_ref、L_refおよび目標速度ξ_ref(i)を設定し、ベクトルyを求める
  Eigen::VectorXd y;
  Eigen::VectorXd y_1(6);//とりあえず

  y_1 <<
    P_ref,
    L_ref;
  for (int i=0; i<4; i++){
    Eigen::MatrixXd y_2(M[i].col(0).size() * 2,M[i].row(0).size());
    y_2 <<
      M[i],
      H[i];
    y_1 += -y_2 *pInv(J[i])* guzai_i_ref[i];
  }
  y = S * y_1;
  
  //ベースリンク速度ξbおよび四肢以外の関節速度θdot_freeを計算する
  Eigen::VectorXd guzai_b;
  //Eigen::VectorXd dth_free;
  Eigen::VectorXd guzai_b_ref;//maybe 0
  guzai_b_ref = Eigen::VectorXd::Zero(6);
  //Eigen::VectorXd dth_free_ref;//maybe 0
  //(guzai_b,dth_free) = pInv(A)*y + E - pInv(A)*A*[guzai_b_ref,dth_free_ref];
  guzai_b = pInv(A)*y + (Eigen::MatrixXd::Identity(6,6) - pInv(A)*A) * guzai_b_ref;
  // std::cout << "A" << std::endl << A <<std::endl;
  // std::cout << "pInv(A)" << std::endl << pInv(A) <<std::endl;
  // std::cout << "(Eigen::MatrixXd::Identity(6,6) - pInv(A)*A) * guzai_b_ref" << std::endl << (Eigen::MatrixXd::Identity(6,6) - pInv(A)*A) * guzai_b_ref <<std::endl;
  //ベース速度guzai_bと目標四肢関節速度guzai_ref(i)より四肢関節速度dth(i)を計算する
  std::vector<Eigen::VectorXd> dth(4);
  for(int i=0; i<4; i++){
    dth[i] = pInv(J[i]) * (guzai_i_ref[i] - A_3[i] * guzai_b);
    // std::cout << "pInv(J[i])" << std::endl << pInv(J[i]) <<std::endl;
    // std::cout << "A_3[i]" << std::endl << A_3[i] <<std::endl;
    // std::cout << "guzai_i_ref[i]" << std::endl << guzai_i_ref[i] <<std::endl;
    // std::cout << "guzai_b" << std::endl << guzai_b <<std::endl;
    std::cout << "dth"<< i << std::endl << dth[i] <<std::endl;
  }
  // std::cout << "dth[0]"<< std::endl << dth[0] <<std::endl;
  //dth(i)とdth_freeを積分して次の時刻の関節角度を求める。繰り返す。
  //thormang3_link_data_[joint_id]->joint_angle_ =+ dth[joint_id] * dt;てきな処理をしてあげればいいのかね
  return true;
}

void RMCModule::process(std::map<std::string, robotis_framework::Dynamixel *> dxls,
                                 std::map<std::string, double> sensors)
{
  if (enable_ == false){
    std::cout << "enable" <<std::endl;
    return;
  }
  /*----- write curr position -----*/
  for (std::map<std::string, robotis_framework::DynamixelState *>::iterator state_iter = result_.begin();
       state_iter != result_.end(); state_iter++)
  {
    std::string joint_name = state_iter->first;

    robotis_framework::Dynamixel *dxl = NULL;
    std::map<std::string, robotis_framework::Dynamixel*>::iterator dxl_it = dxls.find(joint_name);
    if (dxl_it != dxls.end())
      dxl = dxl_it->second;
    else
      continue;

    double joint_curr_position = dxl->dxl_state_->present_position_;
    double joint_goal_position = dxl->dxl_state_->goal_position_;

    present_joint_position_(joint_name_to_id_[joint_name]) = joint_curr_position;
    goal_joint_position_(joint_name_to_id_[joint_name]) = joint_goal_position;
  }

  /*----- forward kinematics -----*/
  for (int id = 1; id <= MAX_JOINT_ID; id++)
    robotis_->thormang3_link_data_[id]->joint_angle_ = goal_joint_position_(id);

  robotis_->calcForwardKinematics(0);

  /* ----- send trajectory ----- */
  if (sub_flag == 1){
    // publishStatusMsg(robotis_controller_msgs::StatusMsg::STATUS_INFO, "Start Trajectory");
    // ik_start_rotation_ = robotis_->thormang3_link_data_[ik_id_end_]->orientation_;
    /* ----- inverse kinematics ----- */
    // setInverseKinematics(cnt_, ik_start_rotation_);
    Eigen::MatrixXd S; //選択行列
    S = Eigen::MatrixXd::Identity(6,6);//今は単位行列

    Eigen::VectorXd P_ref = Eigen::VectorXd::Zero(3);//目標並進運動量
    Eigen::VectorXd L_ref = Eigen::VectorXd::Zero(3);//目標角運動量
    
    std::vector<Eigen::Matrix<double,6,1>> guzai_i_ref(4);//目標四肢先端速度
    guzai_i_ref[0] <<
      goal_kinematics_pose_msg_.pose.position.x,
      goal_kinematics_pose_msg_.pose.position.y,
      goal_kinematics_pose_msg_.pose.position.z,
      0,0,0;
    guzai_i_ref[1] << 0,0,0,0,0,0;
    guzai_i_ref[2] << 0,0,0,0,0,0;
    guzai_i_ref[3] << 0,0,0,0,0,0;

    bool ik_success = calcRMC(S,P_ref,L_ref,guzai_i_ref);
    
    // ik_target_position_ <<
    //   goal_kinematics_pose_msg_.pose.position.x,
    //   goal_kinematics_pose_msg_.pose.position.y,
    //   goal_kinematics_pose_msg_.pose.position.z;
    // Eigen::Quaterniond target_quaternion(goal_kinematics_pose_msg_.pose.orientation.w,
    //                                      goal_kinematics_pose_msg_.pose.orientation.x,
    //                                      goal_kinematics_pose_msg_.pose.orientation.y,
    //                                      goal_kinematics_pose_msg_.pose.orientation.z);
    // ik_target_rotation_ = robotis_framework::convertQuaternionToRotation(target_quaternion);

    // int     max_iter    = 30;
    // double  ik_tol      = 1e-3;
    // bool    ik_success  = robotis_->calcInverseKinematics(ik_id_start_,
    //                                                       ik_id_end_,
    //                                                       ik_target_position_,
    //                                                       ik_target_rotation_,
    //                                                       max_iter, ik_tol,
    //                                                       ik_weight_);
    
    if (ik_success == true){
      for (int id = 1; id <= MAX_JOINT_ID; id++)
        goal_joint_position_(id) = robotis_->thormang3_link_data_[id]->joint_angle_;
    }
    else{
      ROS_INFO("----- ik failed -----");
      ROS_INFO("[end] send trajectory");
    }
    
    sub_flag = 0;
  }
  
  /*----- set joint data -----*/
  for (std::map<std::string, robotis_framework::DynamixelState *>::iterator state_iter = result_.begin();
      state_iter != result_.end(); state_iter++)
  {
    std::string joint_name = state_iter->first;
    result_[joint_name]->goal_position_ = goal_joint_position_(joint_name_to_id_[joint_name]);
    // result_[joint_name]->goal_position_ = des_pos.data;
    // result_[joint_name]->goal_velocity_ = des_pos.data;
    // result_[joint_name]->goal_torque_ = des_pos.data;
  }
}

void RMCModule::stop()
{
  return;
}

bool RMCModule::isRunning()
{
  return false;
}
